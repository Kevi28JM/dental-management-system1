"use client"; 
import React, { useState, useEffect} from "react";
import DatePicker from "react-datepicker";
import axios from "axios";
import db from "@/firebase";
import DentistSidebar from "@/components/DentistSidebar";
import "@/styles/DentistAvailability.css"; // Import custom styles
import { collection, addDoc, getDocs, query, where, deleteDoc, doc, updateDoc, serverTimestamp } from "firebase/firestore";
import { useAuth } from "@/context/AuthContext";
import { useRouter } from 'next/navigation';
import { format, addDays } from "date-fns";


const DentistAvailability = () => {
  const { authData } = useAuth(); // Get user_id from context
  const user_id = authData.user_id;
  const router = useRouter();     // ✅ Initialize router
  console.log("AuthContext user_id:", user_id);

   // States for edit form
  const [editSessionId, setEditSessionId] = useState(null);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [startTime, setStartTime] = useState("16:00");
  const [maxAppointments, setMaxAppointments] = useState(8); // Default max appointments

  //State to store dentistId and availabilities
  const [dentistId, setDentistId] = useState(null);
  const [availabilities, setAvailabilities] = useState([]);
  const [isLoading, setIsLoading] = useState(true); // Optional: prevent UI until check done

  // Helper to format date/time nicely
  const formatDate = (dateStr) => format(new Date(dateStr), 'MMM dd, yyyy');
  const formatTime = (timeStr) => timeStr; // simple, could improve to AM/PM

  // Check dentistId on page load using user_id
  useEffect(() => {
    const checkDentistId = async () => {
      console.log("Checking dentist profile for user_id:", user_id);
      try {
        const response = await axios.get(`http://localhost:5000/api/dentist/byUser/${user_id}`);
        console.log("API response for dentist profile:", response.data);
        const data = response.data;

        if (data.success && data.dentistId) {
          console.log("Dentist profile found. dentistId:", data.dentistId);
          setDentistId(data.dentistId);
        } else {
          console.warn("Dentist profile not complete or not found.");
          alert("Please complete your profile before marking availability.");
          router.push("/DentistProfile");  // ✅ Use router push 
        }
      } catch (error) {
        console.error("Error checking dentist profile:", error);
        alert("Error checking profile. Please try again.");
        router.push("/DentistProfile");  // ✅ Use router push
      } finally {
        setIsLoading(false);
        console.log("Finished checking dentist profile.");
      }
    };

    if (user_id) {
      checkDentistId();
     } else {
      console.warn("user_id is not available yet.");
    }
  }, [user_id, router]);  // ✅ Add router to dependencies



  // ✅ FUNCTION TO AUTO-GENERATE 20 DEFAULT SESSIONS
  const autoGenerateDefaultSessions = async () => {
    const today = new Date();
    const defaultSessions = [];
    for (let i = 0; i < 20; i++) {
      const futureDate = addDays(today, i);
      const session = {
        dentistId: dentistId,
        date: futureDate.toISOString().split("T")[0],
        startTime,
        maxAppointments: parseInt(maxAppointments),
        activeAppointments: 0,
        status: "available",
        createdAt: serverTimestamp(),
      };
      defaultSessions.push(session);
    }

    try {
      const batchAdds = defaultSessions.map((session) => addDoc(collection(db, "availabilities"), session));
      await Promise.all(batchAdds);
      console.log("✅ Auto-generated 20 default sessions");
      alert("No sessions found. 20 default sessions have been created automatically.");
    } catch (error) {
      console.error("Error auto-generating sessions:", error);
      alert("Error auto-generating sessions.");
    }
  };

  // Fetch availabilities from Firestore (for this dentist)
  const fetchAvailabilities = async () => {
    if (!dentistId) return;
    try {
      const q = query(collection(db, "availabilities"), where("dentistId", "==", dentistId));
      const snapshot = await getDocs(q);
      let all = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

      // Remove past sessions (auto delete)
      const todayStr = format(new Date(), 'yyyy-MM-dd');
      const futureSessions = all.filter(item => item.date >= todayStr);
      const expiredSessions = all.filter(item => item.date < todayStr);

      
      // Auto delete expired sessions
      expiredSessions.forEach(async (item) => {
        await deleteDoc(doc(db, "availabilities", item.id));
      });

      
      // ✅ If no future sessions -> auto generate
      if (futureSessions.length === 0) {
        await autoGenerateDefaultSessions();
        return fetchAvailabilities(); // Re-fetch after auto-creation
      }

      futureSessions.sort((a, b) => (a.date + a.startTime).localeCompare(b.date + b.startTime));
      setAvailabilities(futureSessions.slice(0, 20));
    } catch (err) {
      console.error("Error fetching availabilities:", err);
    }
  };
  
  useEffect(() => {
    if (dentistId) {
      fetchAvailabilities();
    }
  }, [dentistId]);


  // Save availability
  const handleSaveAvailability = async () => {
    console.log("Saving availability... dentistId:", dentistId);
    if (!dentistId) {
      console.warn("DentistId not available. Redirecting to profile page.");
      alert("Please complete your profile before marking availability.");
      router.push("/DentistProfile");  // ✅ Use router push
      return;
    }

   const newAvailability = {
    dentistId: dentistId,
    date: selectedDate.toISOString().split("T")[0],
    startTime,
    maxAppointments: parseInt(maxAppointments),
    activeAppointments: 0,
    status: "available",
    createdAt: serverTimestamp(),
  };

  try {
    const q = query(
      collection(db, "availabilities"),
      where("dentistId", "==", newAvailability.dentistId),
      where("date", "==", newAvailability.date)
    );

    const querySnapshot = await getDocs(q);

    if (!querySnapshot.empty) {
      // Session exists for the doctor and date → Update
      const existingDoc = querySnapshot.docs[0];
      const ref = doc(db, "availabilities", existingDoc.id);

      await updateDoc(ref, {
        startTime: newAvailability.startTime,
        maxAppointments: newAvailability.maxAppointments,
      });

      const bookedPatients = await getBookedPatients(existingDoc.id);
      if (bookedPatients.length > 0) {
        notifyPatients(
          bookedPatients,
          "Your appointment session has been updated. Please check details."
        );
      }

      alert("Availability updated successfully!");
    } else {
      // No existing session → Create new
      await addDoc(collection(db, "availabilities"), newAvailability);
      alert("Availability saved successfully!");
}
    // ✅ Reset the form to defaults
    setSelectedDate(new Date());
    setStartTime("16:00");
    setMaxAppointments(8);

    fetchAvailabilities();// refresh list
  } catch (error) {
    console.error("Error saving availability:", error);
    alert("Error saving availability");
  }
};
  
     // Notify patients (dummy - you can replace with real notification later)
  const notifyPatients = (patientIds, message) => {
    patientIds.forEach(pid => {
      console.log(`Notification to patient ${pid}: ${message}`);
    });
  };


  // Fetch booked appointments for a session (availabilityId)
  const getBookedPatients = async (availabilityId) => {
    const q = query(collection(db, "appointments"), where("availabilityId", "==", availabilityId), where("status", "==", "booked"));
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => doc.data().patientId);
  };

  // Delete availability + notify
  const handleDelete = async (availability) => {
    if (window.confirm("Are you sure you want to delete this session?")) {
      const bookedPatients = await getBookedPatients(availability.id);
      await deleteDoc(doc(db, "availabilities", availability.id));
      if (bookedPatients.length > 0) {
        notifyPatients(bookedPatients, "Your appointment has been cancelled because the session was removed.");
      }
      fetchAvailabilities();
    }
  };

  // Edit availability + notify (simple version: update time/maxAppointments)
  const handleEdit = async (availability) => {
    const newTime = prompt("Enter new start time (HH:mm)", availability.startTime);
    const newMax = prompt("Enter new max appointments", availability.maxAppointments);
    if (newTime && newMax) {
      
      const ref = doc(db, "availabilities", availability.id);
      await updateDoc(ref, {
        startTime: newTime,
        maxAppointments: parseInt(newMax),
      });
      const bookedPatients = await getBookedPatients(availability.id);
      if (bookedPatients.length > 0) {
        notifyPatients(bookedPatients, "Your appointment session has been updated. Please check details.");
      }
      fetchAvailabilities();
    }
  };


   return (
    <div className="availability-page">
      <DentistSidebar /> 
      <main className="availability-content"> 
      <h2>Mark Availability</h2>

            <div className="availability-form">
              <div className="form-row">
                <label htmlFor="date">Select Date:</label>
                <DatePicker
                  id="date"
                  selected={selectedDate}
                  onChange={(date) => setSelectedDate(date)}
                  className="form-datepicker"
                />
              </div>

              <div className="form-row">
                <label htmlFor="start-time">Start Time:</label>
                <input
                  id="start-time"
                  type="time"
                  value={startTime}
                  onChange={(e) => setStartTime(e.target.value)}
                  required
                />
              </div>

              <div className="form-row">
                <label htmlFor="max-appointments">Max Appointments:</label>
                <input
                  id="max-appointments"
                  type="number"
                  placeholder="Max Appointments"
                  value={maxAppointments}
                  onChange={(e) => setMaxAppointments(e.target.value)}
                />
              </div>
            </div>

      <button className="save-button" onClick={handleSaveAvailability}>
                  Save Availability
                </button>


       <hr />
      <h3>Upcoming Sessions</h3>
      {availabilities.length === 0 ? (
          <p>No upcoming sessions.</p>
        ) : (
          <div className="scrollable-sessions">
          <div className="sessions-list">
            {availabilities.map((a) => (
              <div className="session-card" key={a.id}>
                <div className="session-info">
                  <span><strong>{formatDate(a.date)}</strong> at {formatTime(a.startTime)}</span>
                  <span>Max: {a.maxAppointments} | Active: {a.activeAppointments}</span>
                </div>
                <div className="session-actions">
                  <button className="btn-edit" onClick={() => handleEdit(a)}>Edit</button>
                  <button className="btn-delete" onClick={() => handleDelete(a)}>Delete</button>
                </div>
              </div>
            ))}
          </div>
          </div>
        )}
      </main>
    </div>
  );
};

export default DentistAvailability;
